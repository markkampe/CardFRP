<HTML>
<HEAD>
<TITLE>Testing</TITLE>
</HEAD>
<BODY>
<center>
<h1>CardFRP Unit Testing</h1>
</center>

<H2>Introduction</H2>
<P>
The unit testing for the CardFRP component is broken into two parts:
<ul>
   <li>	Each basic class will have its own basic unit test suite in the same
	module as the implementation.  All of these test cases will be automatically
	run out of the <tt>__main__()</tt> method, and will <tt>assert()</tt> to
	check the correctness of each test-case.
	<P>
	This is done to keep the per-method test cases tightly bundled with the
	code they exercise, and to make it trivial to re-test a particular module
	after it is updated.
	</li>
   <li> The more interesting test cases use the combined classes to carry out
   	more complex (and realistic) play scenarios.  These are implemented 
	in a <em>pytest</em> test suite.
	</li>
</ul>
Note that these scenario tests are also likely to be interesting as
sample code for using the CardFRP component.
</P>

<H2>Per-Class Unit Testing</H2>

<A name="gameobject"/><H3>GameObject Unit Testing</H3>
<P>
The most interesting code in the <em>GameObject</em> class is the
<tt>possible_actions()</tt> and <tt>accept_action()</tt> methods.
The test cases to exercise them are combinations of situations to
exercise different paths through the code ... and so should be
regarded as <em>white box</em> test cases.
</p>
The <tt>possible_actions()</tt> functionality to be exercised is:
<ul>
   <li>	a newly created <em>GameObject</em> returns no actions and
   	has no ACCURACY, DAMAGE, POWER or STACKS attributes</li>

   <li> if the ACTIONS attribute is set to one, or a list of multiple
   	(simple or compound) verbs, <tt>possible_actions()</tt> will
	return a list containing only (and all of) those verbs</li>

   <li> for each ATTACK verb in ACTIONS, it will correctly compute
   	ACCURACY and DAMAGE by adding the <em>GameObject</em>s
	base-verb and subtype ACCURACY and DAMAGE attributes</li>

   <li> for each non-ATTACK verb in ACTIONS, it will correctly compute
   	POWER and STACKS by adding the <em>GameObject</em>s
	base-verb and subtype POWER and STACKS attributes</li>

   <li> for a compound action (multiple verbs separated by +)
   	the ACCURACY, DAMAGE, POWER and STACKs attributes will
	each be a list, with the correct number of entries,
	and the correct values in each slot (in the same order
	as the verbs)</li>
</ul>

A set of test cases to exercise this functionality would be:
<ul>

   <li> create a new <em>GameObject</em>, get its <tt>possible_actions</tt>,
   	and confirm the emptiness of the list and the absence of any
	ACCURACY/DAMAGE/POWER/STACKS attributes.</li>

   <li> create a new <em>GameObject</em>, with a single ATTACK verb
   	and only base-verb ACCURACY and DAMAGE, and confirm that the
	returned list contains only that verb with those attributes.</li>

   <li> create a new <em>GameObject</em>, with a multiple ACTIONS
	and confirm that <em>GameActions</em> are returned for each.</li>

   <li> create a new <em>GameObject</em>, with multiple compound
   	verbs (both ATTACK and non-ATTACK), some of which have
	sub-type (in addition to base-verb) attributes, 
	<ul>
	   <li> confirm that the ACCURACY/DAMAGE/POWER/STACKS attributes are lists
		that contain the propper values (sums of base and sub-type
		attributes, in the same order as their corresponding verbs)</li>
	   <li> confirm the entries for which there should be no values
	   	(e.g. the third entry in the POWER list when the third verb
		was an ATTACK) are <tt>0</tt>.</li>
	</ul> </li>
</ul>

<P>
The <tt>accept_action()</tt> method in this base class only knows
how to handle attribute-changing verbs.  The functionality to be
exercised is:
<ul>
   <li>	proper summation of general RESISTANCE, and the verb-appropriate
   	RESISTANCE.verb, and RESISTANCE.verb.subtype attributes</li>

   <li> proper iteration through the incoming STACKS, and proper 
   	comparison of TO_HIT and RESISTANCE+D100 to determine whether
	or not a given STACK of the action is delivered</li>

   <li> proper update of receiver attributes in response to successful
   	delivery of (both positive and negative) actions </li>

   <li> ensuring that LIFE cannot be raised above HP</li>

   <li> success is returned only if some STACKS are delivered</li>

   <li> returned status correctly reflects complete RESISTANCE or
   	the number of STACKS successfully delivered</li>
</ul>

A set of test cases to exercise this functionality would be:
<ul>
   <li> pass actions for which there is no RESISTANCE,
   	and different combinations of base, verb, and sub-type
	RESISTANCE, and confirm that the correct sum has been
	computed (for values both above and below TO_HIT)</li>

   <li> pass actions with large numbers of STACKS, and confirm
	<ul>
	   <li> that success is true if any STACKS were delivered</li>
   	   <li>	(by parsing the status) that the number blocked is proprtional to
		(D100 + RESISTANCE - TO_HIT)/100</li>
	   <li> that the affected attributes have been
	   	correctly updates</li>
	   <li> that it is impossible to raise LIFE above HP</li>
	</ul></li>
</ul>
</P>
<P>
The <tt>load()</tt> method will be exercised in the game scenario tests.
</P>

<A name="gameaction"/><H3>GameAction Unit Testing</H3>
<P>
The interesting code is in the <tt>act()</tt> method, where we
recognize and split up compound verbs, decide which (object and
initiator, (base and sub-type) ACCURACY, DAMAGE, POWER and STACKS
attributes apply to each, compute TO_HIT and TOTAL attributes,
and pass these to the recipient's <tt>accept_action()</tt> method.
</P>
<P>
The functionality to be exercised is:
<ul>
   <li> breaking compound (separated by +) verbs into distinct
     	(single-verb) actions, delivered to the recipient,
	in the correct order</li>

   <li>	correct selection and combination of the action's base,
   	verb, and sub-type ACCURACY/POWER attributes with any
	corresponding initiator bonuses to compute the TO_HIT
	for each delivered action</li>

   <li>	correct selection and combination of the action's base,
   	verb, and sub-type DAMAGE/STACKS attributes with any
	corresponding initiator bonuses to compute the TOTAL
	for each delivered action</li>
   	
   <li>	ensuring that those correctly calculated values are
   	received by the recipient's <tt>accept_action()</tt> method</li>
</ul>
</P>
<P>
A set of test cases to exercise this functionality would be:
<ul>
   <li> create <em>GameAction</em>s with a simple ATTACK, and
   	multiple sub-types, each of which has specified
	(base) ACCURACY and DAMAGE attributes.<br>
	Confirm that the action delivered to the recipient
	has the correct verb, TO_HIT and TOTAL attributes.</li>

   <li> create <em>GameAction</em>s with a simple ATTACK, and
   	multiple sub-types, each of which has specified
	(base) ACCURACY and DAMAGE attributes.<br>
	Create an initiator who has base ACCURACY and DAMAGE
	bonuses, as well as sub-type bonuses for some
	(but not all) of the verbs.<br>
	Confirm that the action delivered to the recipient
	has the correct verb, TO_HIT and TOTAL attributes.</li>

   <li> create <em>GameAction</em>s with a simple MENTAL action,
   	and multiple sub-types, each of which has specified
	(base) POWER and STACKS attributes.<br>
	Confirm that the action delivered to the recipient
	has the correct verb, TO_HIT and TOTAL attributes.</li>

   <li> create <em>GameAction</em>s with a simple MENTAL action,
   	and multiple sub-types, each of which has specified
	(base) POWER and STACKS attributes.<br>
	Create an initiator who has base POWER and STACKS
	bonuses, as well as sub-type bonuses for some
	(but not all) of the verbs.<br>
	Confirm that the action delivered to the recipient
	has the correct verb, TO_HIT and TOTAL attributes.</li>

   <li> create a <em>GameAction</em> with a compound action
   	involving both ATTACK and MENTAL/VERBAL/PHYSICAL verbs,
	with ACCURACY, DAMAGE, POWER, and STACKS attributes
	that contain lists of values (corresponding to each
	of the verbs in the compound action).<br>
	Call <tt>act()</tt> to deliver those actions, and
	confirm that each of the test recipient received 
	each of those verbs with its correct TO_HIT and STACKS
	attributes.</li>

   <li> create a <em>GameAction</em> with a compound action,
   	where one of the later actions will fail (POWER=0).
	Call <tt>act()</tt> to deliver those actions, and
	confirm that no verbs after the failure were delivered
	to the recipient.</li>
</ul>

In support of these tests, we will create a test-recipient, who's
<tt>accept_action</tt> method simply returns (as status) the verb
and attribute values.  The test functions can parse this output to
confirm that the received <em>GameAction</em> had the expected
verb, TO_HIT and TOTAL attributes.
</P>
<P>
The test cases to exercise this are combinations of situations to
exercise different paths through the code ... and so should be
regarded as <em>white box</em> test cases.
</P>

<A name="dice"/><H3>Dice Unit Testing</H3>
<P>
The <em>Dice</em> class is simple and independent, and so should be
very easy to test.  There are two obvious types of tests:
<ul>
    <li> tests of all types of legal formula, to make sure
         that the (a) are accepted and (b) that they result
	 in correct rolls.</li>
    <li> tests of likely illegal formula, to make sure that
         they are rejected.</li>
</ul>
The easiest way to test correct rolling is to do many more rolls
than the range width, and ensure that all returned rolls are 
within the expected range.  I will write a routine:
<pre>
    test(
	 string formula,	# dice roll formula
	 int min_expected,	# lowest legal return value
	 int max_expected,	# highest legal return value
	 int num_rolls)		# number of rolls to test
</pre>
that will do this, and use it to test each of the basic types of roll formula:
<TABLE border="1">
    <tr><th align=center>formula</th>
    	<th align=center>min expected</th>
	<th align=center>max expected</th>
	<th align=center>num rolls</th> </tr>
    <tr> <td>"3D4"</td>		<td>3</td>	<td>12</td>	<td>40</td> </tr>
    <tr> <td>"d20"</td>		<td>1</td>	<td>20</td>	<td>80</td> </tr>
    <tr> <td>"D%"</td>		<td>1</td>	<td>100</td>	<td>300</td> </tr>
    <tr> <td>"2D2+3"</td>	<td>5</td>	<td>7</td>	<td>7</td> </tr>
    <tr> <td>"3-9"</td>		<td>3</td>	<td>9</td>	<td>9</td> </tr>
    <tr> <td>"47"</td>		<td>47</td>	<td>47</td>	<td>10</td> </tr>
    <tr> <td>47</td>		<td>47</td>	<td>47</td>	<td>10</td> </tr>
    <tr> <td>"-3"</td>		<td>-3</td>	<td>-3</td>	<td>10</td> </tr>
</TABLE>
</P>

<P>
The obvious formula errors are typos and missing values:
<ul>
    <li> missing number of faces (e.g. "2D")</li>
    <li> non-numeric limits, number of dice, or number of faces (e.g. "D", "xDy", "x-y")</li>
    <li> ranges where the last number is missing or lower than the first (e.g. "-", "4-2", "3-")</li>
    <li> ranges using a separator other than "-" (e.g. "7 to 9")</li>
</ul>


<A name="gameactor"/><H3>GameActor Unit Testing</H3>

<A name="gamecontext"/><H3>GameContext Unit Testing</H3>
<P>
The <em>GameContext</em> implementation is, for the most part, a trivial extension
of the base <em>GameObject</em> class:
<ul>
   <li> the <tt>add_member()</tt> method merely appends a <em>GameActor</em> to the
   	<tt>party</tt> list, and the <tt>get_party()</tt> methods returns that list.</li>

   <li> the <tt>add_npc()</tt> method merely appends a <em>GameActor</em> to the
   	<tt>npcs</tt> list, and the <tt>get_npcs()</tt> methods returns that list.</li>

   <li>	The <tt>get()</tt>, <tt>possible_actions()</tt> methods are only
	interesting in that they pass a request they cannot satisfy up to their parent.</li>
   <li>	The most interesting method is <tt>accept_action()</tt> which knows how to identify
	<em>hidden</em> objects and pass a SEARCH action on to them.</li>
</ul>
</P>
<P>
All of these methods are very simple, and will be well exercised by play scenario tests.
</P>

<A name="integrated"/><H3>Whole Component Game Scenario Testing</H3>
</BODY>
